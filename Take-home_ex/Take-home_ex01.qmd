---
title: "Take home exercise 1"
author: "Brian Lim"
date: "September 2, 2024"
date-modified: "last-modified"
categories:
  - Analysis
  - R
  - sf
  - tidyverse
format: html
editor: visual
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

## **1.1 Exercise Overview**
Millions of people have their lives shattered by armed conflict – wars – every year.

Armed conflict has been on the rise since about 2012, after a decline in the 1990s and early 2000s. First came conflicts in Libya, Syria and Yemen, triggered by the 2011 Arab uprisings. Libya’s instability spilled south, helping set off a protracted crisis in the Sahel region. A fresh wave of major combat followed: the 2020 Azerbaijani-Armenian war over the Nagorno-Karabakh enclave, horrific fighting in Ethiopia’s northern Tigray region that began weeks later, the conflict prompted by the Myanmar army’s 2021 power grab and Russia’s 2022 assault on Ukraine. Add to those 2023’s devastation in Sudan and Gaza. Around the globe, more people are dying in fighting, being forced from their homes or in need of life-saving aid than in decades.

In this study, I will apply spatial point patterns analysis methods to discover the spatial and spatio-temporal distribution of armed conflict in Myanmar.

## **2.2 Data Acquisition**
The data sets that we will be using are the following:
- Armed conflict data of Myanmar between 2021-2024. This data can be downloaded from Armed Conflict Location & Event Data [ACLED](https://acleddata.com/analysis/), an independent, impartial, international non-profit organization collecting data on violent conflict and protest in all countries and territories in the world, should be used.

In terms of event types, I will be focusing on these 4 event types: **Battles**, **Explosion/Remote violence**, **Strategic developments**, and **Violence against civilians**.

In terms of study period, students should focus on quarterly armed conflict events from January 2021 until June 2024.


## **2.3 Getting Started**
For this exercise, the following R packages will be used:

-   [**tidyverse**](https://www.tidyverse.org/) for performing data science tasks such as importing, wrangling and visualising data.

-   [**sf**](https://cran.r-project.org/web/packages/sf/) for handling geospatial data.

-   [**spatstat**](https://spatstat.org/), a comprehensive package for point pattern analysis. We'll use it to perform first- and second-order spatial point pattern analyses and to derive kernel density estimation (KDE) layers.

-   [**raster**](https://cran.r-project.org/web/packages/raster/), a package for reading, writing, manipulating, and modeling gridded spatial data (rasters). We will use it to convert image outputs generated by spatstat into raster format.

-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html), a set of tools for manipulating geographic data, mainly used here to convert spatial objects into the *ppp* format required by **spatstat**.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html), a package for creating high-quality static and interactive maps, leveraging the Leaflet API for interactive visualizations.


As readr, tidyr and dplyr are part of tidyverse package. The code chunk below will suffice to install and load the required packages in RStudio.

To install and load these packages into the R environment, we use the `p_load` function from the `pacman` package:

```{r}
pacman::p_load(sf, raster, spatstat, tmap, tidyverse, lubridate, purrr)
```

## **2.4 Importing Data into R**

```{r}
acled_sf <- read_csv("data/ACLED-Southeast_Asia-Myanmar(1).csv") %>% 
  st_as_sf(coords = c(
    "longitude", "latitude"), crs = 4326) %>% 
  st_transform(crs= 3414)%>%
  mutate(event_date = dmy(event_date)) %>%
  mutate(quarter = paste0(year(event_date), " Q", quarter(event_date)))
```
Importing the boundaries and regions of Myanmar
```{r}
regions_sf <- st_read(dsn = "data/myanmar", 
                layer = "mmr_polbnda2_adm1_250k_mimu_1") %>%
                st_transform(crs = 3414)
```
After importing the boundary and region data, we can check that what was imported is correct:
```{r}
tmap_mode('view')
tm_shape(regions_sf) +
  tm_polygons()
tmap_mode('plot')
```

## **2.5 Battles of the civil war in Myanmar**
### **2.5.1 Battles overview**
from January 2021 until June 2024, there have been countless battles fought by all actors of the civil war, as seen from the following plot: 
```{r}
#| eval: false
tmap_mode('view')
acled_sf %>%
  filter(event_type == "Battles") %>%
  tm_shape() +
  tm_dots() +
  tm_layout(title = "Battles in Myanmar (2021-2024)")
tmap_mode("plot")
```
```{r}
# Function to create combined events object with owin object
plot_battles_by_quarter <- function(quarter_data, quarter_name) {
  quarter_data_ppp <- as.ppp(st_coordinates(quarter_data), st_bbox(quarter_data))
  regions_owin <- as.owin(regions_sf)
  quarter_data_regions_ppp = quarter_data_ppp[regions_owin]
  plot(quarter_data_regions_ppp,
     main = paste("Battles in Myanmar -", quarter_name),
     xlab = "Longitude", ylab = "Latitude")
}
```

```{r}
# Filter for the event type battles
acled_battles_2021 <- acled_sf %>%
  filter(event_type == "Battles")

# Get a list of unique quarters
quarters <- unique(acled_battles_2021$quarter)

# Loop over each quarter and generate the plot
map(quarters, ~ {
  quarter_data <- acled_battles_2021 %>% filter(quarter == .x)
  plot_battles_by_quarter(quarter_data, .x)
})
```
#### **2.5.1 2021 Q1**
As seen below, I combined the point events with the polygon feature to create a `ppp` object confined to the Singapore region for the Q1 2021. This provides a clear image of where most of the battles took place, mainly in the northern Shan region.
```{r}
quarter_data_sf <- acled_battles_2021 %>% filter(quarter == "2021 Q1")
plot_battles_by_quarter(quarter_data_sf, "2021 Q1")
```
```{r}
regions <- as_Spatial(regions_sf)
regions
```
```{r}
quarter_data <- as_Spatial(quarter_data_sf)
quarter_data
```
```{r}
quarter_data_sp <- as(quarter_data, "SpatialPoints")
regions_sp <- as(regions, "SpatialPolygons")
```

```{r}
quarter_data_ppp <- as.ppp(st_coordinates(quarter_data_sf), st_bbox(quarter_data_sf))
quarter_data_ppp
```

```{r}
any(duplicated(quarter_data_ppp))
multiplicity(quarter_data_ppp)
```
```{r}
sum(multiplicity(quarter_data_ppp) > 1)
```
```{r}
quarter_data_ppp_jit <- rjitter(quarter_data_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
any(duplicated(quarter_data_ppp_jit))
```

```{r}
regions_owin <- as.owin(regions_sf)
```
```{r}
quarter_data_regions_ppp = quarter_data_ppp_jit[regions_owin]
summary(quarter_data_regions_ppp)
```


```{r}
plot(quarter_data_regions_ppp)
```
##### **2.5.1.1 First-order Spatial Point Patterns Analysis**
```{r}
kde_quarter_data_regions_bw <- density(quarter_data_regions_ppp,
                                       sigma=bw.diggle,
                                       edge=TRUE,
                                       kernel="gaussian")
plot(kde_quarter_data_regions_bw)
```
```{r}
bw <- bw.diggle(quarter_data_regions_ppp)
bw
```
```{r}
quarter_data_regions_ppp.km <- rescale.ppp(quarter_data_regions_ppp, 1000, "km")

kde_quarter_data_regions_bw <- density(quarter_data_regions_ppp.km, 
                              sigma=bw.diggle, 
                              edge=TRUE, 
                              kernel="gaussian")
plot(kde_quarter_data_regions_bw)
```
```{r}
bw.CvL(quarter_data_regions_ppp.km)
bw.scott(quarter_data_regions_ppp.km)
bw.ppl(quarter_data_regions_ppp.km)
bw.diggle(quarter_data_regions_ppp.km)
```
```{r}
kde_quarter_data_regions.ppl <- density(quarter_data_regions_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
quarter_data_regions_ppp.km <- rescale.ppp(quarter_data_regions_ppp, 1000, "km")
kde_quarter_data_regions.bw <- density(quarter_data_regions_ppp.km, 
                              sigma=bw.diggle, 
                              edge=TRUE, 
                              kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_quarter_data_regions.bw, main = "bw.diggle")
plot(kde_quarter_data_regions.ppl, main = "bw.ppl")
```


```{r}
par(mfrow=c(2,2), mar=c(1, 1, 1, 1), cex=0.5)
plot(density(quarter_data_regions_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(quarter_data_regions_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(quarter_data_regions_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(quarter_data_regions_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```
```{r}
quarter_data_regions_600 <- density(quarter_data_regions_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(quarter_data_regions_600)
```

```{r}
kde_quarter_data_regions_adaptive <- adaptive.density(quarter_data_regions_ppp.km, method="kernel")
plot(kde_quarter_data_regions_adaptive)
```

```{r}
par(mfrow=c(1,2))
plot(kde_quarter_data_regions.bw, main = "Fixed Bandwidth")
plot(kde_quarter_data_regions_adaptive, main = "Adaptive Bandwidth")
```

```{r}
kde_quarter_data_regions_bw_raster <- raster(kde_quarter_data_regions.bw)
projection(kde_quarter_data_regions_bw_raster) <- CRS("+init=EPSG:3414")
kde_quarter_data_regions_bw_raster
```

```{r}
tm_shape(kde_quarter_data_regions_bw_raster) + 
  tm_raster("layer", palette = "viridis") +
  tm_layout(
    legend.position = c("right", "bottom"),
    frame = FALSE
  )
```
```{r}
clarkevans.test(quarter_data_regions_ppp.km, correction="none", clipregion="regions_owin", alternative="clustered", nsim=99)
```
##### **2.5.1.2 Second-order Spatial Point Patterns Analysis**
```{r}
G_CK = Gest(quarter_data_regions_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```
----------------------------------------------------------------------------

```{r}
# Example: Calculate KDE for Q1 2021
kde_2021_Q1 <- calculate_kde(acled_sf, 2021, 1)

# Visualize the KDE using tmap
tm_shape(kde_2021_Q1) +
  tm_raster(palette = "-RdBu", title = "KDE (Q1 2021)", alpha = 0.7) +
  tm_layout(main.title = "Quarterly KDE for Armed Conflicts in Myanmar (Q1 2021)",
            main.title.position = "center")
```


```{r}
# Loop through each year and quarter
years <- unique(acled_sf$year)
quarters <- 1:4

for (yr in years) {
  for (qtr in quarters) {
    # Calculate KDE
    kde_result <- calculate_kde(acled_sf, yr, qtr)
    
    # Plot KDE
    print(
      tm_shape(kde_result) +
        tm_raster(palette = "-RdBu", title = paste("KDE (Q", qtr, yr, ")", sep=" "), alpha = 0.7) +
        tm_layout(main.title = paste("Quarterly KDE for Armed Conflicts in Myanmar (Q", qtr, yr, ")", sep=" "),
                  main.title.position = "center")
    )
  }
}
```

```{r}
# Save KDE as a raster file
raster::writeRaster(kde_2021_Q1, "KDE_2021_Q1.tif")
```













