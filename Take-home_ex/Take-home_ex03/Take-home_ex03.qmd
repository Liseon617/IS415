```{r}
pacman::p_load(sf, raster, spatstat, tmap, tidyverse, RColorBrewer, spdep, sfdep, ggplot2, jsonlite, olsrr, corrplot, ggpubr, GWmodel, gtsummary, Metrics, rsample, SpatialML)
```

```{r}
mrt_sf <- st_read(dsn = "data/mrt_stations", layer = "mrt_stations")

st_crs(mrt_sf)
```

```{r}
mpsz_sf <- st_read(dsn = "data/MP14_SUBZONE_WEB_PL", layer = "MP14_SUBZONE_WEB_PL")

st_crs(mpsz_sf)
```

```{r}
rental_sf <- read_rds("data/rental_sf.rds")
```

```{r}
summary(rental_sf)
glimpse(rental_sf)
```

```{r}
set.seed(1234)
rental_split <- initial_split(rental_sf, 
                              prop = 6.5/10,)
train_data <- training(rental_split)
test_data <- testing(rental_split)
```

```{r}
write_rds(train_data, "data/rds/model/train_data.rds")
write_rds(test_data, "data/rds/model/test_data.rds")
```

```{r}
train_data <- read_rds("data/rds/model/train_data.rds")
test_data <- read_rds("data/rds/model/test_data.rds")
```

```{r}
rental_nogeo <- rental_sf %>%
  select(7:19) %>%
  st_drop_geometry()
```

```{r}
names(rental_nogeo)
```

::: panel-tabset
## Order - AOE

```{r, fig.height=12,fig.width=12}
corrplot::corrplot(cor(rental_nogeo), 
                   diag = FALSE, 
                   order = "AOE",
                   tl.pos = "td", 
                   tl.cex = 0.5, 
                   method = "number", 
                   type = "upper")
```

## Order - FPC

```{r, fig.height=12,fig.width=12}
corrplot::corrplot(cor(rental_nogeo), 
                   diag = FALSE, 
                   order = "FPC",
                   tl.pos = "td", 
                   tl.cex = 0.5, 
                   method = "number", 
                   type = "upper")
```

## Type - Lower

```{r, fig.height=12,fig.width=12}
corrplot::corrplot(cor(rental_nogeo), 
                   diag = FALSE, 
                   order = "AOE",
                   tl.pos = "ld", 
                   tl.cex = 0.5, 
                   method = "number", 
                   type = "lower")
```

## Type - Full

```{r, fig.height=12,fig.width=12}
corrplot::corrplot(cor(rental_nogeo), 
                   diag = FALSE, 
                   order = "AOE",
                   tl.pos = "full", 
                   tl.cex = 0.5, 
                   method = "number", 
                   type = "full")
```

## Method - Circle

```{r, fig.height=12,fig.width=12}
corrplot::corrplot(cor(rental_nogeo), 
                   diag = FALSE, 
                   order = "AOE",
                   tl.pos = "td", 
                   tl.cex = 0.5, 
                   method = "circle", 
                   type = "upper")
```
:::

## Retriving the Stored Data

```{r}
train_data <- read_rds("data/rds/model/train_data.rds")
test_data <- read_rds("data/rds/model/test_data.rds")
```

```{r}
price_mlr <- lm(monthly_rent ~ 
                  no_of_kindergarten_500m + prox_kindergarten +
                  no_of_childcare_500m + no_of_hawker_500m + prox_childcare +
                  prox_hawker + no_of_busstop_500m + prox_busstop + 
                  no_of_shoppingmall_1km + prox_shoppingmall +
                  prox_mrt + prox_prisch +
                  prox_cbd,
                data=train_data)

summary(price_mlr)
```

Based on the coefficient section, we can see that not all the independent variables are statistically significant, and some variables can be removed from our model based on their p-value field (Pr > 0.05). 

The following variables should be removed from the model due to their high p-values, indicating they are not statisitically significant predictors of monthly rent:
**1. no_of_kindergarten_500m (p = 0.443537)**
**2. no_of_childcare_500m (p = 0.301437)**
**3. prox_childcare (p = 0.785864)**    
**4. no_of_shoppingmall_1km (p = 0.107131)**
**5. prox_prisch (p = 0.465858)**

Now we will update the model
```{r}
price_mlr <- lm(monthly_rent ~ 
                  prox_kindergarten + no_of_hawker_500m +
                  prox_hawker + no_of_busstop_500m + prox_busstop +
                  prox_shoppingmall + prox_mrt +
                  prox_cbd,
                data=train_data)

summary(price_mlr)
```

```{r}
write_rds(price_mlr, "data/rds/model/price_mlr.rds")
```

```{r}
price_mlr <- read_rds("data/rds/model/price_mlr.rds")
```

```{r}
train_data_sp <- as_Spatial(train_data)
train_data_sp
```

```{r}
bw_adaptive <- bw.gwr(monthly_rent ~ 
                  prox_kindergarten + no_of_hawker_500m +
                  prox_hawker + no_of_busstop_500m + prox_busstop +
                  prox_shoppingmall + prox_mrt +
                  prox_cbd,
                  data=train_data_sp,
                  approach="CV",
                  kernel="gaussian",
                  adaptive=TRUE,
                  longlat=FALSE)
```
```{r}
write_rds(bw_adaptive, "data/rds/model/bw_adaptive.rds")
```

```{r}
bw_adaptive <- read_rds("data/rds/model/bw_adaptive.rds")
```
:::{.callout-tip title="Inisghts"}
1. **Bandwidth Optimization Process:**
-   The model iteratively tests various bandwidths (in terms of the number of neighbors) to find the lowest CV score. Lower CV scores indicate a better fit.
-   The CV score gradually decreases as the bandwidth narrows, meaning that fewer neighbors allow the model to capture local variations in rental prices better.

2. **Optimal Bandwidth and CV Score:**
-   The optimal bandwidth is found when the CV score reaches its minimum (in this case, at 32 neighbors, with a CV score of 5,613,088,820).
-   This bandwidth suggests that a localized model considering around 32 neighboring data points best captures the spatial patterns in rental prices across different areas in the dataset.
3. **Spatial Heterogeneity:**
-   From this, monthly rental prices are influenced by highly localized conditions rather than broad, regional trends, hence the need for a smaller, adaptive bandwidth.
Different neighborhoods likely have unique rental price drivers (e.g., access to public amenities, proximity to transport), which the smaller bandwidth allows the model to capture more precisely.
:::

After identifying the optimal adaptive bandwidth (`bw_adaptive`) for running a Geographically Weighted Regression (GWR) with cross-validation, we use this `bw_adaptive` value in the next step with `gwr.basic` will allow you to fit the GWR model itself.

In short, this step allows you to create a spatially-varying model, which helps identify how different factors contribute to `monthly_rent` differently across locations.

```{r}
gwr_adaptive <- gwr.basic(formula = monthly_rent ~ 
                  prox_kindergarten + no_of_hawker_500m +
                  prox_hawker + no_of_busstop_500m + prox_busstop +
                  prox_shoppingmall + prox_mrt +
                  prox_cbd,
                  data=train_data_sp,
                          bw=bw_adaptive, 
                          kernel = 'gaussian', 
                          adaptive=TRUE,
                          longlat = FALSE)
```

```{r}
write_rds(gwr_adaptive, "data/rds/model/gwr_adaptive.rds")
```

```{r}
gwr_adaptive <- read_rds("data/rds/model/gwr_adaptive.rds")
```

This code produces the GWR model using the adaptive bandwidth previously calculated. Running this step is essential for performing the actual localized regression analysis and obtaining spatially varying coefficients, which will reveal how the influence of each predictor on rental prices varies across the area. This model will give you insights into spatial patterns in rental prices, helping you to understand which factors are most significant in different locations.

```{r}
gwr_adaptive
```

{.callout-tip title="Insights"}
This analysis captures how each variable's impact on rental prices varies across different spatial locations. Here’s a breakdown of the key results:

### 1. **Global Regression Results**
   - The global regression provides an overall look at the relationships across the entire dataset without spatial variation.
   - Significant predictors (marked by `***` or `**`) include `prox_kindergarten`, `no_of_hawker_500m`, `prox_hawker`, `no_of_busstop_500m`, `prox_shoppingmall`, `prox_mrt`, and `prox_cbd`.
   - The Adjusted R-squared value for the global model is low (0.0378), indicating that this model doesn’t capture much of the variability in rental prices, suggesting spatial variability which GWR can better account for.

### 2. **GWR Results**
   - **Adaptive Bandwidth**: GWR used an adaptive bandwidth of 32 neighbors, which allows each point in the study area to capture localized trends.
   - **Spatially Varying Coefficients**: Each predictor shows variability across the region, with minimum, maximum, and quartile ranges that capture different local effects on rental prices. For example:
     - **`prox_kindergarten`**: Its effect on rent varies from highly negative to slightly positive, showing that proximity to kindergartens can have a contrasting impact depending on the area.
     - **`no_of_hawker_500m`** and **`prox_hawker`**: The effect of hawker centers varies significantly, with some areas showing a strong positive association and others a negative one, reflecting localized preferences or economic differences.
     - **`prox_mrt`** and **`prox_cbd`**: Proximity to MRT and CBD impacts rental prices differently across the region, which could indicate that some areas value access to transport and central business zones more than others.
   
### 3. **Model Diagnostics**
   - **Effective Number of Parameters**: 1855.56, which is high, reflects the complexity added by allowing coefficients to vary spatially.
   - **R-squared and Adjusted R-squared**: The GWR model explains more variability in rental prices (`R-squared: 0.3649`) than the global model, demonstrating that including spatial variation improves explanatory power.
   - **AIC and BIC**: The AIC and BIC values are lower than those of the global model, indicating a better model fit when considering spatial variations.

### 4. **Insights and Interpretation**
   - The GWR results show that rental prices are influenced by factors that vary in importance across different locations. For example:
      - Areas close to MRT stations or shopping malls may experience varying rental prices depending on how desirable those amenities are locally.
      - Proximity to CBD has a negative coefficient in some areas, likely due to higher supply of rentals closer to CBD that don’t hold premium values, while areas farther may see a positive correlation due to scarcity.
   - This analysis reveals valuable insights for urban planning, real estate development, or policy-making, as it indicates where certain amenities (like MRT access) influence rental pricing more strongly.

The GWR model thus captures complex spatial heterogeneity in rental price determinants, which would be missed by a non-spatial global regression model.
:::



### Converting the test data from sf data.frame to SpatialPointDataFrame

```{r}
test_data_sp <- test_data %>%
  as_Spatial()
test_data_sp
```

### Computing adaptive bandwidth for the test data

```{r}
#| eval: false
gwr_bw_test_adaptive <- bw.gwr(monthly_rent ~ 
                  prox_kindergarten + no_of_hawker_500m +
                  prox_hawker + no_of_busstop_500m + prox_busstop +
                  prox_shoppingmall + prox_mrt +
                  prox_cbd,
                  data=test_data_sp,
                  approach="CV",
                  kernel="gaussian",
                  adaptive=TRUE,
                  longlat=FALSE)
```
::: {.callout-tip title="Insight"}
1. The adaptive bandwidth of 39 indicates a focus on very localized neighborhoods, as only 39 neighbors are considered for each location. This can be advantageous for capturing specific local effects on rental prices related to amenities and transport access.

2. The trend in CV scores shows a diminishing return; at a certain point, increasing the number of neighbors does not provide significant improvements in model performance, which can help inform decisions about complexity versus interpretability.

## Best Bandwidth
- The lowest CV score observed was 3127154219, corresponding to an adaptive bandwidth of 39. This suggests that using this bandwidth should yield the best GWR model fit for your dataset.
- As the adaptive bandwidth decreases, the CV score tends to improve, indicating a more localized model that potentially captures finer spatial variations in the data.

:::
```{r}
#| eval: false
write_rds(gwr_bw_test_adaptive, "data/rds/model/gwr_bw_test_adaptive.rds")
```

```{r}
gwr_bw_test_adaptive <- read_rds("data/rds/model/gwr_bw_test_adaptive.rds")
```

## Preparing coordinates data

### Extracting coordinates data

The code chunk below extract the x,y coordinates of the full, training and test data sets.

```{r}
coords <- st_coordinates(rental_sf)
coords_train <- st_coordinates(train_data)
coords_test <- st_coordinates(test_data)
```

Before continue, we write all the output into rds for future used.

```{r}
#| eval: false
coords_train <- write_rds(coords_train, "data/rds/model/coords_train.rds" )
coords_test <- write_rds(coords_test, "data/rds/model/coords_test.rds" )
```

```{r}
#| eval: false
coords_train <- read_rds("data/rds/model/coords_train.rds" )
coords_test <- read_rds("data/rds/model/coords_test.rds" )
```

### Droping geometry field

First, we will drop geometry column of the sf data.frame by using `st_drop_geometry()` of sf package.

```{r}
train_data <- train_data %>% 
  st_drop_geometry()
```

## Calibrating Random Forest Model

In this section, you will learn how to calibrate a model to predict HDB rental price by using random forest function of [**ranger**](https://cran.r-project.org/web/packages/ranger/index.html) package.

```{r}
set.seed(1234)
rf <- ranger(monthly_rent ~ 
                  prox_kindergarten + no_of_hawker_500m +
                  prox_hawker + no_of_busstop_500m + prox_busstop +
                  prox_shoppingmall + prox_mrt +
                  prox_cbd,
             data=train_data)
rf
```

```{r}
write_rds(rf, "data/rds/model/rf.rds")
```

```{r}
rf <- read_rds("data/rds/model/rf.rds")
```

## Calibrating Geographical Random Forest Model

In this section, you will learn how to calibrate a model to predict HDB rental price by using `grf()` of [**SpatialML**](https://cran.r-project.org/web/packages/ranger/index.html) package.

### Calibrating using training data

The code chunk below calibrate a geographic ranform forest model by using `grf()` of **SpatialML** package.

```{r}
#| eval: false
set.seed(1234)
gwRF_adaptive <- grf(formula = monthly_rent ~ 
                  prox_kindergarten + no_of_hawker_500m +
                  prox_hawker + no_of_busstop_500m + prox_busstop +
                  prox_shoppingmall + prox_mrt +
                  prox_cbd,
                     dframe=train_data, 
                     bw=55,
                     kernel="adaptive",
                     coords=coords_train)
```

Let's save the model output by using the code chunk below.

```{r eval=FALSE}
#| eval: false
write_rds(gwRF_adaptive, "data/rds/model/gwRF_adaptive.rds")
```

The code chunk below can be used to retrieve the save model in future.

```{r}
gwRF_adaptive <- read_rds("data/rds/model/gwRF_adaptive.rds")
```











### Predicting by using test data

#### Preparing the test data

The code chunk below will be used to combine the test data with its corresponding coordinates data.

```{r}
test_data <- cbind(test_data, coords_test) %>%
  st_drop_geometry()
```

#### Predicting with test data

Next, `predict.grf()` of spatialML package will be used to predict the rental value by using the test data and gwRF_adaptive model calibrated earlier.

```{r}
#| eval: false
gwRF_pred <- predict.grf(gwRF_adaptive, 
                           test_data, 
                           x.var.name="X",
                           y.var.name="Y", 
                           local.w=1,
                           global.w=0)
```

Before moving on, let us save the output into rds file for future use.

```{r}
#| eval: false
gwRF_pred <- write_rds(gwRF_pred, "data/rds/model/GRF_pred.rds")
```

#### Converting the predicting output into a data frame

The output of the `predict.grf()` is a vector of predicted values. It is wiser to convert it into a data frame for further visualisation and analysis.

```{r}
gwRF_pred <- read_rds("data/rds/model/GRF_pred.rds")
```

```{r}
GRF_pred_df <- as.data.frame(gwRF_pred)
```

In the code chunk below, `cbind()` is used to append the predicted values onto test_datathe

```{r}
test_data_p <- cbind(test_data, GRF_pred_df)
```

```{r}
write_rds(test_data_p, "data/rds/model/test_data_p.rds")
```

### Calculating Root Mean Square Error

The root mean square error (RMSE) allows us to measure how far predicted values are from observed values in a regression analysis. In the code chunk below, rmse() of Metrics package is used to compute the RMSE.

```{r}
rmse(test_data_p$monthly_rent, 
     test_data_p$gwRF_pred)
```

### Visualising the predicted values

Alternatively, scatterplot can be used to visualise the actual rental price and the predicted rental price by using the code chunk below.

```{r}
ggplot(data = test_data_p,
       aes(x = gwRF_pred,
           y = monthly_rent)) +
  geom_point()
```

::: {.callout-tip title="Notes"}
A better predictive model should have the scatter point close to the diagonal line. The scatter plot can be also used to detect if any outliers in the model.
:::























```{r}
northeasten.islands <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "NORTH-EASTERN ISLANDS")
southern.islands <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "SOUTHERN GROUP")
sudong <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "SUDONG")
semakau <- subset(mpsz_sf,mpsz_sf$SUBZONE_N == "SEMAKAU")

outerislands <- dplyr::bind_rows(list(northeasten.islands,southern.islands,sudong,semakau))
```

```{r}
sg_sf <- st_difference(mpsz_sf, outerislands)
```

```{r}
par(mar = c(0,0,0,0))
plot(st_geometry(sg_sf))
```

```{r}
# Step 1: Read the CSV files
mrt_lrt_station <- read.csv("data/mrt_lrt_stations.csv")
bus_stop <- read.csv("data/bus_stops.csv")
hdb_2024 <- read.csv("data/hdb_2024-30sep.csv")
```

```{r}
# Check the first few rows and the structure of the dataset
head(hdb_2024)
str(hdb_2024$month)
hdb_2024$month <- as.Date(hdb_2024$month)
```

```{r}
hdb_2022_filtered <- hdb_2024[hdb_2024$month >= as.Date("2017-01-01") & hdb_2024$month <= as.Date("2022-12-31"), ]
```

```{r}
# Step 2: Convert to spatial objects
# Convert MRT/LRT stations to spatial points
mrt_lrt_station_sf <- st_as_sf(mrt_lrt_station, coords = c("LONGITUDE", "LATITUDE"), crs = 4326)

# Convert Bus stops to spatial points
bus_stop_sf <- st_as_sf(bus_stop, coords = c("Longitude", "Latitude"), crs = 4326)

# Convert hdb_2024 to spatial points
hdb_2022_filtered <- st_as_sf(hdb_2022_filtered, coords = c("longitude", "latitude"), crs = 4326)
```

```{r}
# Step 1: Read the JSON file
json_file_path <- "data/private_property_transaction.json"
  data <- fromJSON(json_file_path)

# Step 2: Extract x and y coordinates for all properties
# Initialize vectors to store the coordinates
street <- c()
x_coordinates <- c()
y_coordinates <- c()

# Loop through each result (result1 to result5)
for (i in 1:length(data)) {
  # Construct the result name dynamically (result1, result2, etc.)
  result_name <- paste0("result", i)
  
  # Check if the result exists in the data
  if (result_name %in% names(data)) {
    # Extract street, x, and y coordinates
    street <- c(street, data[[result_name]]$street)
    x_coordinates <- c(x_coordinates, data[[result_name]]$x)
    y_coordinates <- c(y_coordinates, data[[result_name]]$y)
  }
}

# Step 3: Create a data frame to store the results
coordinates_df <- data.frame(
  street = street,
  x = as.numeric(x_coordinates),  # Convert to numeric
  y = as.numeric(y_coordinates)   # Convert to numeric
)
# Step 4: Remove entries with missing x or y values
coordinates_df <- na.omit(coordinates_df)

private_properties_sf <- st_as_sf(coordinates_df, coords = c("x", "y"), crs = 3414)  # SVY21 CRS

# Step 4: Check all the coordinates
st_crs(private_properties_sf)
st_crs(mrt_lrt_station_sf)
st_crs(bus_stop_sf)
st_crs(hdb_2022_filtered)
```

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| fig-width: 12

tm_shape(sg_sf) +  # Assuming regions_sf is the Singapore region shapefile
  tm_polygons(col = "REGION_N") +  # Color regions
  tm_shape(mrt_lrt_station_sf) +  # Add MRT/LRT stations
  tm_dots(col = "blue", size = 0.4) +  # Plot as blue dots
  tm_shape(hdb_2022_filtered) +  # Add bus stops
  tm_dots(col = "black") +  # Plot as red dots
  tm_shape(private_properties_sf) +  # Add bus stops
  tm_dots(col = "black") +  # Plot as red dots
  tm_layout(main.title = "MRT/LRT Stations and Bus Stops in Singapore",
            main.title.position = "center",
            main.title.size = 1.6)
```
