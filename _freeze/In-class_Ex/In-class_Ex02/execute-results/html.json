{
  "hash": "c44f95a72ab953e04550a44990f49994",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In Class exercise 2\"\nauthor: \"Brian Lim\"\ndate: \"August 26, 2024\"\ndate-modified: \"last-modified\"\ncategories:\n  - Analysis\n  - R\n  - sf\n  - tidyverse\nformat: html\neditor: visual\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n## **2.0 Getting Started**\n\nFor this in-class exercise, two R packages will be used:\n\n-   `sf` for importing, managing, and processing geospatial data\n\n-   `tidyverse` for performing data science tasks such as importing, wrangling and visualising data.\n\nTo install and load these packages into the R environment, we use the `p_load` function from the `pacman` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf,tidyverse)\n```\n:::\n\n\n## **2.1 Working with Master Plan 2014 Subzone Boundary Data**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz14_shp <- st_read(dsn = \"data/MasterPlan2014SubzoneBoundaryWebSHP\", \n                  layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Users\\blzll\\OneDrive\\Desktop\\Y3S1\\IS415\\Quarto\\IS415\\In-class_Ex\\data\\MasterPlan2014SubzoneBoundaryWebSHP' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\nThe code chunk below demonstrates data conversion from SHP file format to KML file format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz14_kml <- st_write(mpsz14_shp, \n  \"data/MasterPlan2014SubzoneBoundaryWebKML.kml\",\n  delete_dsn = TRUE)\n```\n:::\n\n\nThe delete_dsn argument relates to the dsn (Data Source Name) to delete original source before writing the new file\n\n## **2.2 Working with Master Plan 2019 Subzone Boundary Data**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz19_kml <- st_read(\"data/MasterPlan2019SubzoneBoundaryNoSeaKML.kml\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `URA_MP19_SUBZONE_NO_SEA_PL' from data source \n  `C:\\Users\\blzll\\OneDrive\\Desktop\\Y3S1\\IS415\\Quarto\\IS415\\In-class_Ex\\data\\MasterPlan2019SubzoneBoundaryNoSeaKML.kml' \n  using driver `KML'\nSimple feature collection with 332 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY, XYZ\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz19_shp <- st_read(dsn = \"data/MasterPlan2019SubzoneBoundaryWebSHP\", \n                      layer = \"MPSZ-2019\") %>%\n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MPSZ-2019' from data source \n  `C:\\Users\\blzll\\OneDrive\\Desktop\\Y3S1\\IS415\\Quarto\\IS415\\In-class_Ex\\data\\MasterPlan2019SubzoneBoundaryWebSHP' \n  using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n## **2.3 Working with population data**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv(\"data/respopagesextod2023/respopagesextod2023.csv\")\n```\n:::\n\n\n### **2.3.1 Data Preparation**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2023 <- popdata %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup() %>%\n  pivot_wider(names_from = AG,\n              values_from = POP)\n\ncolnames(popdata2023)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"PA\"          \"SZ\"          \"0_to_4\"      \"10_to_14\"    \"15_to_19\"   \n [6] \"20_to_24\"    \"25_to_29\"    \"30_to_34\"    \"35_to_39\"    \"40_to_44\"   \n[11] \"45_to_49\"    \"50_to_54\"    \"55_to_59\"    \"5_to_9\"      \"60_to_64\"   \n[16] \"65_to_69\"    \"70_to_74\"    \"75_to_79\"    \"80_to_84\"    \"85_to_89\"   \n[21] \"90_and_Over\"\n```\n\n\n:::\n:::\n\n\nAs seen above, unlike other programming languages, R indexes from '1' instead of '0'. The rows begin from `[1]`,`[6]`,`[11]`, etc.\n\n### **2.3.2 Data Wrangling**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2023 <- popdata2023 %>%\nmutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[14])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:13])+\nrowSums(.[15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2023 <- popdata2023 %>%\nmutate_at(.vars = vars(PA, SZ),\n          .funs = list(toupper))\n```\n:::\n\n\n### **2.3.3 Joining the attribute data and geospatial data**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_2023 <- left_join(mpsz19_shp, popdata2023,\n                       by = c(\"SUBZONE_N\" = \"SZ\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npop2023_mpsz <- left_join(popdata2023, mpsz19_shp,\n                       by = c(\"SZ\" = \"SUBZONE_N\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}