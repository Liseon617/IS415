{
  "hash": "589f3f32f2166a80036e4b048c7b6cbb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In Class exercise 5\"\nauthor: \"Brian Lim\"\ndate: \"September 16, 2024\"\ndate-modified: \"last-modified\"\ncategories:\n  - Analysis\n  - R\n  - sf\n  - tidyverse\nformat: html\neditor: visual\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true  \n  cache: true\n---\n\n\n## **5.0 Notes**:\n\n-   A way to define spatial neighbourhood (Polygon vs Centroid)\n\n    -   Defining spatial weights\n\n    -   Using a centroid to determine the neighhours around a particular area\n\n    -   centroid would be able to gauge how far any neighbour is close to the area in focus\n\n        -   Limitations of centroid: irregular shaped areas, land\n\n-   Contiguity Neighbours\n\n    -   Common shared boundary\n\n        -   Rook's case, Bishop's case, Queen's case\n\n    -   Multiple order used in measuring contiguity\n\n    -   Can be seen a graph with differing cases focusing on where their neighbours are connected\n\n## **5.1 Installing and Loading the R packages**\n\nFor the purpose of this study, five R packages will be used. They are:\n\n-   [**sf**](https://r-spatial.github.io/sf/), a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.\n\n-   [**spatstat**](https://spatstat.org/), a comprehensive package for point pattern analysis. We'll use it to perform first- and second-order spatial point pattern analyses and to derive kernel density estimation (KDE) layers.\n\n-   [**spdep**](https://cran.r-project.org/web/packages/spdep/), an R package focused on spatial dependence and spatial econometrics. It includes functions for computing spatial weights, neighborhood structures, and spatially lagged variables, which are crucial for understanding spatial relationships in data.\n\n-   [**knitr**](https://cran.r-project.org/web/packages/knitr/index.html), an R package that enables dynamic report generation. It integrates R code with Markdown or LaTeX to create reproducible documents, which is useful for documenting and sharing your analysis workflows.\n\n-   [**tidyverse**](https://cran.r-project.org/web/packages/tidyverse/index.html), a collection of R packages designed for data science. It includes packages like `dplyr` for data manipulation, `ggplot2` for data visualization, and `tidyr` for data tidying, all of which are essential for handling and analyzing data efficiently in a clean and consistent manner.\n\n-   [**GWmodel**](https://cran.r-project.org/web/packages/GWmodel/index.html), a collection of techniques from a particular branch of spatial statistics,termed geographically-weighted (GW) models. GW models suit situations when data are not described well by some global model, but where there are spatial regions where a suitably localised calibration provides a better description. \n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr, GWmodel)\n```\n:::\n\n\n### **5.1.1 Import shapefile into r environment**\n\nThe code chunk below uses [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sf <- st_read(dsn = \"data/In-class_Ex05/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\Users\\blzll\\OneDrive\\Desktop\\Y3S1\\IS415\\Quarto\\IS415\\In-class_Ex\\data\\In-class_Ex05\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n### **5.1.2 Import csv file into r environment**\n\nNext, we will import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R dataframe class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/In-class_Ex05/aspatial/Hunan_2012.csv\")\nhunan2012\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 88 × 29\n   County    City   avg_wage deposite    FAI Gov_Rev Gov_Exp    GDP GDPPC    GIO\n   <chr>     <chr>     <dbl>    <dbl>  <dbl>   <dbl>   <dbl>  <dbl> <dbl>  <dbl>\n 1 Anhua     Yiyang    30544   10967   6832.    457.   2703  13225  14567  9277.\n 2 Anren     Chenz…    28058    4599.  6386.    221.   1455.  4941. 12761  4189.\n 3 Anxiang   Chang…    31935    5517.  3541     244.   1780. 12482  23667  5109.\n 4 Baojing   Hunan…    30843    2250   1005.    193.   1379.  4088. 14563  3624.\n 5 Chaling   Zhuzh…    31251    8241.  6508.    620.   1947  11585  20078  9158.\n 6 Changning Hengy…    28518   10860   7920     770.   2632. 19886  24418 37392 \n 7 Changsha  Chang…    54540   24332  33624    5350    7886. 88009  88656 51361 \n 8 Chengbu   Shaoy…    28597    2581.  1922.    161.   1192.  2570. 10132  1681.\n 9 Chenxi    Huaih…    33580    4990   5818.    460.   1724.  7755. 17026  6644.\n10 Cili      Zhang…    33099    8117.  4498.    500.   2306. 11378  18714  5843.\n# ℹ 78 more rows\n# ℹ 19 more variables: Loan <dbl>, NIPCR <dbl>, Bed <dbl>, Emp <dbl>,\n#   EmpR <dbl>, EmpRT <dbl>, Pri_Stu <dbl>, Sec_Stu <dbl>, Household <dbl>,\n#   Household_R <dbl>, NOIP <dbl>, Pop_R <dbl>, RSCG <dbl>, Pop_T <dbl>,\n#   Agri <dbl>, Service <dbl>, Disp_Inc <dbl>, RORP <dbl>, ROREmp <dbl>\n```\n\n\n:::\n:::\n\n\n### **5.1.3 Performing relational join**\n\nThe code chunk below will be used to update the attribute table of *hunan*'s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* data frame. This is performed by using *left_join()* of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sf <- left_join(hunan_sf,hunan2012)%>%\n  select(1:3, 7, 15, 16, 31, 32)\n```\n:::\n\n### **5.1.4 Store file locally**\nWriting to rds would allow for quick retrieval of required data\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sf <- read_rds(\"data/rds/hunan_sf.rds\")\n```\n:::\n\n\n## **5.2 Converting to SpatialPolgyonDataFrame**\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sp <- hunan_sf %>%\n  as_Spatial()\n```\n:::\n\n\n## **5.3 Geographically Weighted Summary Statistics with Adaptive Bandwidth**\nAkaike information criterion (AIC) approach to determine the recommended number of neighbours\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_AIC_adapt <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach = 'AIC',\n                 adaptive = TRUE,\n                 kernel = 'bisquare',\n                 longlat = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAdaptive bandwidth (number of nearest neighbours): 62 AICc value: 1923.156 \nAdaptive bandwidth (number of nearest neighbours): 46 AICc value: 1920.469 \nAdaptive bandwidth (number of nearest neighbours): 36 AICc value: 1917.324 \nAdaptive bandwidth (number of nearest neighbours): 29 AICc value: 1916.661 \nAdaptive bandwidth (number of nearest neighbours): 26 AICc value: 1914.897 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \n```\n\n\n:::\n:::\n\nCross validation approach to determine the recommended number of neighbours\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_CV_adapt <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach = 'CV',\n                 adaptive = TRUE,\n                 kernel = 'bisquare',\n                 longlat = T)         \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAdaptive bandwidth: 62 CV score: 15515442343 \nAdaptive bandwidth: 46 CV score: 14937956887 \nAdaptive bandwidth: 36 CV score: 14408561608 \nAdaptive bandwidth: 29 CV score: 14198527496 \nAdaptive bandwidth: 26 CV score: 13898800611 \nAdaptive bandwidth: 22 CV score: 13662299974 \nAdaptive bandwidth: 22 CV score: 13662299974 \n```\n\n\n:::\n:::\n\n\n## **5.4 Geographically Weighted Summary Statistics with Fixed Bandwidth**\nAkaike information criterion (AIC) approach to determine the recommended number of neighbours\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_AIC_fixed <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach = 'AIC',\n                 adaptive = FALSE,\n                 kernel = 'bisquare',\n                 longlat = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFixed bandwidth: 357.4897 AICc value: 1927.631 \nFixed bandwidth: 220.985 AICc value: 1921.547 \nFixed bandwidth: 136.6204 AICc value: 1919.993 \nFixed bandwidth: 84.48025 AICc value: 1940.603 \nFixed bandwidth: 168.8448 AICc value: 1919.457 \nFixed bandwidth: 188.7606 AICc value: 1920.007 \nFixed bandwidth: 156.5362 AICc value: 1919.41 \nFixed bandwidth: 148.929 AICc value: 1919.527 \nFixed bandwidth: 161.2377 AICc value: 1919.392 \nFixed bandwidth: 164.1433 AICc value: 1919.403 \nFixed bandwidth: 159.4419 AICc value: 1919.393 \nFixed bandwidth: 162.3475 AICc value: 1919.394 \nFixed bandwidth: 160.5517 AICc value: 1919.391 \n```\n\n\n:::\n:::\n\nCross validation approach to determine the recommended number of neighbours\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_CV_fixed <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach = 'CV',\n                 adaptive = FALSE,\n                 kernel = 'bisquare',\n                 longlat = T)         \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFixed bandwidth: 357.4897 CV score: 16265191728 \nFixed bandwidth: 220.985 CV score: 14954930931 \nFixed bandwidth: 136.6204 CV score: 14134185837 \nFixed bandwidth: 84.48025 CV score: 13693362460 \nFixed bandwidth: 52.25585 CV score: Inf \nFixed bandwidth: 104.396 CV score: 13891052305 \nFixed bandwidth: 72.17162 CV score: 13577893677 \nFixed bandwidth: 64.56447 CV score: 14681160609 \nFixed bandwidth: 76.8731 CV score: 13444716890 \nFixed bandwidth: 79.77877 CV score: 13503296834 \nFixed bandwidth: 75.07729 CV score: 13452450771 \nFixed bandwidth: 77.98296 CV score: 13457916138 \nFixed bandwidth: 76.18716 CV score: 13442911302 \nFixed bandwidth: 75.76323 CV score: 13444600639 \nFixed bandwidth: 76.44916 CV score: 13442994078 \nFixed bandwidth: 76.02523 CV score: 13443285248 \nFixed bandwidth: 76.28724 CV score: 13442844774 \nFixed bandwidth: 76.34909 CV score: 13442864995 \nFixed bandwidth: 76.24901 CV score: 13442855596 \nFixed bandwidth: 76.31086 CV score: 13442847019 \nFixed bandwidth: 76.27264 CV score: 13442846793 \nFixed bandwidth: 76.29626 CV score: 13442844829 \nFixed bandwidth: 76.28166 CV score: 13442845238 \nFixed bandwidth: 76.29068 CV score: 13442844678 \nFixed bandwidth: 76.29281 CV score: 13442844691 \nFixed bandwidth: 76.28937 CV score: 13442844698 \nFixed bandwidth: 76.2915 CV score: 13442844676 \nFixed bandwidth: 76.292 CV score: 13442844679 \nFixed bandwidth: 76.29119 CV score: 13442844676 \nFixed bandwidth: 76.29099 CV score: 13442844676 \nFixed bandwidth: 76.29131 CV score: 13442844676 \nFixed bandwidth: 76.29138 CV score: 13442844676 \nFixed bandwidth: 76.29126 CV score: 13442844676 \nFixed bandwidth: 76.29123 CV score: 13442844676 \n```\n\n\n:::\n:::\n\nIt can be observed that unlike the determination of the adaptive bandwidth, fixed bandwidth yield vastly different results for the methods of AIC and Cross Validation\n\n## **5.4 Geographically Weighted Summary Statistics with adaptive Bandwidth**\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat <- gwss(data = hunan_sp,\n               vars = \"GDPPC\",\n               bw = bw_AIC_adapt,\n               kernel = \"bisquare\",\n               adaptive = TRUE,\n               longlat = T)\ngwstat[[\"SDF\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatialPolygonsDataFrame \nfeatures    : 88 \nextent      : 108.7831, 114.2544, 24.6342, 30.12812  (xmin, xmax, ymin, ymax)\ncrs         : +proj=longlat +datum=WGS84 +no_defs \nvariables   : 5\nnames       :         GDPPC_LM,        GDPPC_LSD,       GDPPC_LVar,         GDPPC_LSKe,         GDPPC_LCV \nmin values  : 13688.6986033259, 4282.59917616925, 18340655.7037255, -0.215059890053628, 0.200050258645349 \nmax values  : 49005.8382943034, 22568.8411539952, 509352591.034267,    3.7525953469342, 0.801815253056721 \n```\n\n\n:::\n:::\n\nCode chunk below is used to extract SDF data table from gwss object output from gwss(). It will be converted into data.frame by using `as.data.frame()`\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat_df <- as.data.frame(gwstat$SDF)\n```\n:::\n\n\nNext, cbind() is used to append the newly derived data.frame onto *hunan_sf* sf data.frame in the code chunk below\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_gstat <- cbind(hunan_sf, gwstat_df)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hunan_gstat) +\n  tm_fill(\"GDPPC_LM\",\n  n = 5,\n  style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Distribution of geographically weighted mean\",\n            main.title.position = \"center\",\n            main.title.size = 2.0,\n            legend.text.size = 1.2,\n            legend.height = 1.50,\n            legend.width = 1.50,\n            frame = TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-15-1.png){width=1152}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}