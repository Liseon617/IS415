---
title: "1st & 2nd Order Spatial Point Patterns Analysis Methods"
author: "Brian Lim"
date: "August 29, 2024"
date-modified: "last-modified"
categories:
  - Analysis
  - R
  - sf
  - tmap
  - tidyverse
  - raster
  - spatstat
format: html
editor: visual
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

## **3.1 Exercise Overview**

In this hands-on exercise, I learn how to to analyze spatial point patterns in R. On top of that I learn to apply first- and second-order analyses to assess the randomness of point distributions, and how to visualize and interpret the spatial concentration of facilities using Kernel Density Estimation (KDE)

Spatial Point Pattern Analysis involves evaluating the distribution of a set of points on a surface. These points can represent the locations of various events or facilities, such as:

-   Events: Crime occurrences, traffic accidents, or disease outbreaks.
-   Facilities: Business services like coffee shops, fast food outlets, or essential facilities such as childcare and eldercare centers.

In this hands-on exercise, we aim to explore the spatial distribution of childcare centers in Singapore using functions from the `spatstat` package. Specifically, we will address the following questions:

-   Randomness of Distribution: Are childcare centers in Singapore randomly distributed across the country?
-   Clusters and Concentrations: If the distribution is not random, where are the areas with higher concentrations of childcare centers?

## **3.2 Data Acquisition**

Three data set will be used to answer these question. They are:

1.  CHILDCARE: A point feature dataset containing the location and attribute information of childcare centers in Singapore. This dataset was downloaded from Data.gov.sg and is in GeoJSON format.
2.  MP14_SUBZONE_WEB_PL: A polygon feature dataset providing information on URA's 2014 Master Plan Planning Subzone boundaries. This data is in ESRI Shapefile format and was also downloaded from Data.gov.sg.
3.  CostalOutline: A polygon feature dataset showing the national boundary of Singapore. This dataset is provided by the Singapore Land Authority (SLA) and is in ESRI Shapefile format.

## **3.3 Getting Started**

For this exercise, we will use the following 5 R packages:

-   [**sf**](https://r-spatial.github.io/sf/), a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.

-   [**spatstat**](https://spatstat.org/), a comprehensive package for point pattern analysis. We'll use it to perform first- and second-order spatial point pattern analyses and to derive kernel density estimation (KDE) layers.

-   [**raster**](https://cran.r-project.org/web/packages/raster/), a package for reading, writing, manipulating, and modeling gridded spatial data (rasters). We will use it to convert image outputs generated by spatstat into raster format.

-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html), a set of tools for manipulating geographic data, mainly used here to convert spatial objects into the *ppp* format required by **spatstat**.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html), a package for creating high-quality static and interactive maps, leveraging the Leaflet API for interactive visualizations.

To install and load these packages into the R environment, we use the `p_load` function from the `pacman` package:

```{r}
pacman::p_load(sf, raster, spatstat, tmap, tidyverse)
```

## **3.4 Importing Data into R**

### **3.4.1 Importing the spatial data**

In this section, we'll use the st_read() function from the sf package to import three geospatial datasets into R:

```{r}
childcare_sf <- st_read("data/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "data", layer="CostalOutline")
```

```{r}
mpsz_sf <- st_read(dsn = "data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

The following code chunk changes the referencing system of the newly created simple feature data frames to Singapore national projected coordinate system.

```{r}
childcare_sf <- st_transform(childcare_sf, crs = 3414)
mpsz_sf <- st_transform(mpsz_sf, crs = 3414)
```

### **3.4.2 Mapping the geospatial data sets**

After verifying that all datasets share the same CRS, it's useful to visualize them to confirm their spatial alignment.

```{r}
tmap_mode("plot")
tm_shape(mpsz_sf) +
  tm_polygons() + 
  tm_shape(childcare_sf) + 
  tm_dots() 
```

In this code chunk:

-   `tm_shape(mpsz_sf)`: Sets the base layer to the Singapore subzones.
-   `tm_polygons()`: Plots the subzones with a light blue fill and a dark blue border.
-   `tm_shape(childcare_sf)`: Adds an overlay layer for the childcare centers.
-   `tm_dots()`: Plots the childcare centers as red dots with a black border.

```{r}
tmap_mode('view')

tm_shape(childcare_sf) +
  tm_dots()

tmap_mode('plot')
```

By ensuring that all geospatial layers align correctly within the same map extent, we confirm that their CRS and coordinate values are consistent—a critical aspect of any geospatial analysis.

```{r}
tmap_mode('plot')
```

Notice that at the interactive mode, **tmap** is using [**leaflet for R**](https://rstudio.github.io/leaflet/) API. The advantage of this interactive pin map is it allows us to navigate and zoom around the map freely. We can also query the information of each simple feature (i.e. the point) by clicking of them. Last but not least, you can also change the background of the internet map layer. Currently, three internet map layers are provided. They are: ESRI.WorldGrayCanvas, OpenStreetMap, and ESRI.WorldTopoMap. The default is ESRI.WorldGrayCanvas.

## **3.5 Geospatial Data wrangling**

Although simple feature data frame is gaining popularity again sp’s Spatial\* classes, there are, however, many geospatial analysis packages require the input geospatial data in sp’s Spatial\* classes. In this section, you will learn how to convert simple feature data frame to sp’s Spatial\* class.

### **3.5.1 Converting sf data frames to sp’s Spatial\* class**

To work with certain geospatial analysis packages that require data in `sp`’s Spatial\* class, you can convert simple feature (`sf`) data frames to these classes using the `as_Spatial()` function from the `sf` package. Below is the code to convert the `sf` objects to `sp`'s Spatial\* classes:

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

After conversion, you can display the information of these three `Spatial*` classes as follows:

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

### **3.5.2 Converting the Spatial\* class into generic sp format**

To prepare data for use in the spatstat package, you first need to convert the `Spatial*` classes into a generic `sp` format:

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

Then, you can display the properties of these `sp` objects:

```{r}
childcare_sp
```

```{r}
sg_sp
```

### **3.5.3 Converting the generic sp format into spatstat’s ppp format**

To analyze spatial point patterns, you need to convert the `sp` objects into `ppp` objects, which are used by the `spatstat` package:

```{r}
childcare_ppp <- as.ppp(st_coordinates(childcare_sf), st_bbox(childcare_sf))
childcare_ppp
```

Now, let us plot ***childcare_ppp*** and examine the different.

```{r}
plot(childcare_ppp)
```

You can take a quick look at the summary statistics of the newly created ppp object by using the code chunk below.

```{r}
summary(childcare_ppp)
```

Notice the warning message about duplicates. In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident.

### **3.5.4 Handling duplicated points**

To determine the existence of duplicate points, we can check for duplicates in your Point Pattern (PPP) object object by using the code chunk below.

```{r}
any(duplicated(childcare_ppp))
```

To count the number of points at each location, we can use the `multiplicity()` function as shown in the code chunk below.

```{r}
multiplicity(childcare_ppp)
```

To check for the number of locations that have more than one point event, we can use the code chunk below.

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

The output show 128 duplicated point events.

To view the locations of these duplicate point events, we will plot `childcare` data by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode('plot')
tmap_mode('view')
```

There are three ways to overcome this problem.

1.  The first and easiest way is to delete the duplicates. But, that will also mean that some useful point events will be lost.

2.  The second solution is use jittering. If duplicates are hard to spot, you can apply a slight jitter to the points' coordinates. Jittering will slightly displace the points so that overlapping points are separated on the map.

3.  The third solution is to make each point "unique" and then attach the duplicates of the points to the patterns as **marks**, as attributes of the points. Then you would need analytical techniques that take into account these marks.

The `jitter` parameter will slightly move each point by a small, random amount. This can help to visually separate points that are in the same space.

```{r}
tm_shape(childcare) +
  tm_dots(jitter=0.1, alpha=0.4, size=0.05)
```

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

After jittering we can check if there are any duplicate point in this geospatial data

```{r}
any(duplicated(childcare_ppp_jit))
```

### **3.5.5 Creating owin object**

To confine analysis to a geographical area, convert the `SpatialPolygon` object to an `owin` object of `spatstat`:

```{r}
sg_owin <- as.owin(sg_sf)
  
plot(sg_owin)
```

Further analysis can be done through the *summary()* function of Base R:

```{r}
summary(sg_owin)
```

### **3.5.6 Combining point events object and owin object**

Finally, you can combine the point events with the polygon feature to create a `ppp` object confined to the Singapore region

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
summary(childcareSG_ppp )
```

```{r}
plot(childcareSG_ppp)
```

## **3.6 First-order Spatial Point Patterns Analysis**

In this section, we will learn how to perform first-order Spatial Point Pattern Analysis (SPPA) using the `spatstat` package. The focus will be on:

1.  **Deriving Kernel Density Estimation (KDE) layers** for visualizing and exploring the intensity of point processes.

2.  **Performing Confirmatory Spatial Point Patterns Analysis** using Nearest Neighbour statistics.

### **3.6.1 Kernel Density Estimation**

Kernel Density Estimation (KDE) is a non-parametric way to estimate the intensity (density) of spatial point patterns. It helps in visualizing the spatial distribution of points by smoothing the point pattern to create a continuous surface.

#### **3.6.1.1 Computing kernel density estimation using automatic bandwidth selection method**

To compute the KDE for the spatial point pattern of childcare services in Singapore, we'll use the [*density()*](https://rdrr.io/cran/spatstat/man/density.ppp.html) function from the `spatstat` package. This function allows for various configurations:

-   **Automatic Bandwidth Selection:** We'll use  [*bw.diggle()*](https://rdrr.io/cran/spatstat/man/bw.diggle.html) , a method that selects an optimal bandwidth based on the data. Other methods like  [*bw.CvL()*](https://rdrr.io/cran/spatstat/man/bw.CvL.html) ,  [*bw.scott()*](https://rdrr.io/cran/spatstat/man/bw.scott.html), or  [*bw.ppl()*](https://rdrr.io/cran/spatstat/man/bw.ppl.html) can also be used depending on the specific needs of the analysis.

-   **Smoothing Kernel:** The default kernel used is Gaussian. Other options include "Epanechnikov", "Quartic", or "Disc".

-   **Edge Correction:** The intensity estimate is corrected for edge effects to reduce bias, following methods described by Jones (1993) and Diggle (2010).

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 

plot(kde_childcareSG_bw)
```

In this example, the density values range from 0 to 0.000035, which are quite small. This is because the unit of measurement is in meters, making the density values "number of points per square meter".

To check the bandwidth used:

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

#### **3.6.1.2 Rescalling KDE values**

The small density values are due to the measurement unit being in meters. To make the results more interpretable, we can rescale the spatial point pattern from meters to kilometers.

The code chunk below rescale the point pattern to kilometers, recompute the KDE with the rescaled data, and plots the rescaled KDE

```{r}
childcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, 1000, "km")

kde_childcareSG_bw <- density(childcareSG_ppp.km, 
                              sigma=bw.diggle, 
                              edge=TRUE, 
                              kernel="gaussian")
plot(kde_childcareSG_bw)
```

The KDE output will look identical to the original, but the density values will now be more comprehensible, reflecting "number of points per square kilometer."

### **3.6.2 Working with different automatic badwidth methods**

Different bandwidth selection methods can produce different smoothing results:

-   **`bw.CvL()`**: Cross-validation based on the likelihood.

-   **`bw.scott()`**: Scott's rule of thumb.

-   **`bw.ppl()`**: Likelihood cross-validation proposed by Diggle.

```{r}
bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

*Recommendation:* 1. Baddeley et. (2016) suggested the use of the *bw.ppl()* algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters.

2.  But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the *bw.diggle()* method seems to work best.

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
childcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, 1000, "km")
kde_childcareSG.bw <- density(childcareSG_ppp.km, 
                              sigma=bw.diggle, 
                              edge=TRUE, 
                              kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### **3.6.3 Working with different kernel methods**

Beyond the Gaussian kernel, three other kernels can be used to compute KDE:

-   **Epanechnikov**

-   **Quartic**

-   **Disc**

```{r}
par(mfrow=c(2,2), mar=c(1, 1, 1, 1), cex=0.5)
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## **3.7 Fixed and Adaptive KDE**

### **3.7.1 Computing KDE by using fixed bandwidth**

Next, you will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of childcareSG_ppp.km object is in kilometer, hence the 600m is 0.6km.

To compute a KDE layer using a fixed bandwidth of 0.6 km, use the following code:

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

This will generate a KDE layer with a consistent bandwidth across the entire study area, useful for uniform spatial point patterns.

### **3.7.2 Computing KDE by using adaptive bandwidth**

Adaptive bandwidth methods are more suitable for spatial point patterns with high variability, such as urban versus rural areas. The `adaptive.density()` function of **spatstat** can be used to create a KDE layer that adjusts the bandwidth based on point density:

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

To compare the outputs of fixed and adaptive bandwidth KDE:

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed Bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive Bandwidth")
```

### **3.7.3 Converting KDE output into grid object.**

For mapping purposes, KDE outputs can be converted into grid and raster formats 1. **Converting to Grid Object**:

```{r}
gridded_kde_childcareSG_bw <- as(kde_childcareSG.bw, "SpatialGridDataFrame")
spplot(gridded_kde_childcareSG_bw)

```

2.  **Converting to Raster Object**:

```{r}
kde_childcareSG_bw_raster <- raster(kde_childcareSG.bw)
kde_childcareSG_bw_raster
```

3.  **Assigning Projection System**: Ensure the CRS (Coordinate Reference System) is assigned correctly:

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

4.  **Visualizing the Raster**: Finally, use the `tmap` package to visualize the raster in a cartographic map:

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("layer", palette = "viridis") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)

```

Notice that the raster values are encoded explicitly onto the raster pixel using the values in “v”” field.

### **3.7.4 Comparing Spatial Point Patterns using KDE**

In this section, we will learn to compare KDE of childcare at Ponggol, Tampines, Chua Chu Kang and Jurong West planning regions.

#### **3.7.4.1 Extracting study area**

```{r}
pg <- mpsz_sf %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

Plotting target planning areas 1. **Ponggol**

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
```

2.  **Tampines**

```{r}
plot(tm, main = "Tampines")
```

3.  **Choa Chu Kang**

```{r}
plot(ck, main = "Choa Chu Kang")
```

4.  **Jurong West**

```{r}
plot(jw, main = "Jurong West")
```

#### **3.7.4.2 Creating *owin* object**

Now, we will convert these sf objects into owin objects that is required by **spatstat**.

The `owin` objects represent the study areas as window objects, which are necessary for spatial point pattern analysis in `spatstat`. These are created by converting the `sf` objects (`pg`, `tm`, `ck`, and `jw`) representing different regions into `owin` format:

```{r}
pg_owin = as.owin(pg)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)
```

#### **3.7.4.3 Combining childcare points and the study area**

we are then able to extract childcare that is within the specific region to perform analysis later on.

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

The childcare centers within each specific region are extracted using the `owin` objects.

These point patterns (`ppp` objects) are then rescaled from meters to kilometers:

```{r}
childcare_pg_ppp.km = rescale.ppp(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale.ppp(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale.ppp(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale.ppp(childcare_jw_ppp, 1000, "km")
```

Finally, the four study areas and the locations of the childcare centers are plotted:

```{r}
par(mfrow=c(2,2), mar=c(1, 1, 1, 1), cex=0.5)
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### **3.7.4.4 Computing KDE**

The Kernel Density Estimate (KDE) for each area is computed using the density() function, with the bw.diggle method to derive the bandwidth:

```{r}
par(mfrow=c(2,2), mar=c(1, 1, 1, 1), cex=0.5)
plot(density(childcare_pg_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian"), main="Punggol")
plot(density(childcare_tm_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian"), main="Tampines")
plot(density(childcare_ck_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian"), main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian"), main="Jurong West")
```

#### **3.7.4.5 Computing Fixed Bandwidth KDE**

For comparison, a fixed bandwidth of 250 meters is used to compute KDE for the same areas:

```{r}
par(mfrow=c(2,2), mar=c(1, 1, 1, 1), cex=0.5)
plot(density(childcare_pg_ppp.km, sigma=0.25, edge=TRUE, kernel="gaussian"), main="Punggol")
plot(density(childcare_tm_ppp.km, sigma=0.25, edge=TRUE, kernel="gaussian"), main="Tampines")
plot(density(childcare_ck_ppp.km, sigma=0.25, edge=TRUE, kernel="gaussian"), main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, sigma=0.25, edge=TRUE, kernel="gaussian"), main="Jurong West")
```

## **3.8 Nearest Neighbour Analysis**

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using [*clarkevans.test()*](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat**.

### **3.8.1 Testing Spatial Point Patterns using Clark and Evans Test**

The Clark-Evans test is performed to assess the spatial distribution of the childcare centers. The hypotheses are:

-   **H0**: The distribution of childcare centers is random.

-   **H1**: The distribution of childcare centers is clustered.

The test is conducted as follows:

```{r}
clarkevans.test(childcareSG_ppp, correction="none", clipregion="sg_owin", alternative="clustered", nsim=99)
```

Result Interpretation:

-   **R = 0.55631**: The R-value is less than 1, indicating a tendency towards clustering.

-   **p-value \< 2.2e-16**: The p-value is extremely small, suggesting that the clustering pattern is statistically significant. The null hypothesis of CSR (Complete Spatial Randomness) is rejected in favor of the alternative hypothesis, indicating that the childcare centers in Singapore are clustered.

### **3.8.2 Clark and Evans Test: Punggol planning area**

In the code chunk below,  [*clarkevans.test()*](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **spatstat** is used to performs Clark-Evans test of aggregation for childcare centre in Punggol planning area.

```{r}
clarkevans.test(childcare_pg_ppp,
                correction="none",
                clipregion=NULL,
                alternative="two.sided",
                nsim=999)
```

Interpretation:

1.  **R = 0.91163**: The R-value is close to 1, indicating a spatial distribution that is close to random.

-   **p-value = 0.1867**: The p-value is greater than 0.05, meaning there is no statistically significant evidence to reject the null hypothesis of CSR. This suggests that the childcare centers in the Punggol area are randomly distributed and do not exhibit significant clustering or regularity.

## **3.9 Second-order Spatial Point Patterns Analysis**

This section introduces second-order analyses of spatial point patterns, focusing on measuring interaction between points.

## **3.10 Analysing Spatial Point Process Using G-Function**

The G function measures the distribution of the distances from an arbitrary event to its nearest event. In this section, you will learn how to compute G-function estimation by using [*Gest()*](https://rdrr.io/cran/spatstat/man/Gest.html) of **spatstat** package. You will also learn how to perform monta carlo simulation test using [*envelope()*](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package.

### **3.10.1 Choa Chu Kang planning area**

#### **3.10.1.1 Computing G-function estimation**

The code chunk below is used to compute G-function using *Gest()* of **spatat** package.

```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

#### **3.10.1.2 Performing Complete Spatial Randomness Test**

To perform a Complete Spatial Randomness (CSR) test using a Monte Carlo simulation with the G-function in R, you are correctly using the `envelope()` function from the `spatstat` package. Here's how you can carry out the test and interpret the results:

1.  **Hypothesis Definition**:

    -   **Null Hypothesis (Ho)**: The distribution of childcare services at Choa Chu Kang is randomly distributed (i.e., follows CSR).

    -   **Alternative Hypothesis (H1)**: The distribution of childcare services at Choa Chu Kang is not randomly distributed.

2.  **Set Up the Test**:

    -   You will perform a Monte Carlo test using the G-function, which measures the distribution of nearest-neighbor distances.

```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
plot(G_CK.csr)
```

### **3.10.2 Tampines planning area**

#### **3.10.2.1 Computing G-function estimation**

```{r}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

#### **3.10.2.2 Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, we perform the Complete Spatial Randomness (CSR) test for the distribution of childcare services in Tampines using the G-function in R, you can follow the steps and code chunk below:

-   **Hypothesis**:

    -   **Null Hypothesis (Ho)**: The distribution of childcare services at Tampines is randomly distributed (CSR).

    -   **Alternative Hypothesis (H1)**: The distribution of childcare services at Tampines is not randomly distributed

```{r}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
plot(G_tm.csr)
```

## **3.11 Analysing Spatial Point Process Using F-Function**

The F-function estimates the empty space function F(r) from a point pattern within a defined window. It provides insights into the spatial distribution by measuring the distribution of distances from a randomly chosen location in the study area to the nearest event (e.g., childcare centers). We will compute the F-function for the Choa Chu Kang and Tampines planning areas and perform a Complete Spatial Randomness (CSR) test using Monte Carlo simulations.

We will learn how to compute F-function estimation by using [*Fest()*](https://rdrr.io/cran/spatstat/man/Fest.html) of **spatstat** package, and how to perform monta carlo simulation test using [*envelope()*](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package.

### **3.11.1 Choa Chu Kang planning area**

#### **3.11.1.1 Computing F-fucntion estimate**

```{r}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

#### **3.11.1.2 Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns at Choa Chu Kang, a hypothesis test using the F-function will be conducted. The hypotheses are:

-   **Ho (Null Hypothesis):** The distribution of childcare services at Choa Chu Kang is randomly distributed.

-   **H1 (Alternative Hypothesis):** The distribution of childcare services at Choa Chu Kang is not randomly distributed.

The null hypothesis will be rejected if the p-value is smaller than the alpha value of 0.001.

**Monte Carlo Test Using F-function:**

```{r}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
```

```{r}
plot(F_CK.csr)
```

### **3.11.2 Tampines planning area**

#### **3.11.2.1 Computing F-fucntion estimation**

Monte Carlo test with F-fucntion

```{r}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

#### **3.11.2.2 Computing F-fucntion estimation**

Similar to before, a hypothesis test will be conducted to confirm the observed spatial patterns above. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
```

```{r}
plot(F_tm.csr)
```

## **3.12 Analysing Spatial Point Process Using K-Function**

K-function measures the number of events found up to a given distance of any particular event. In this section, you will learn how to compute K-function estimates by using [*Kest()*](https://rdrr.io/cran/spatstat/man/Kest.html) of **spatstat** package. You will also learn how to perform monta carlo simulation test using *envelope()* of spatstat package.

### **3.12.1 Choa Chu Kang planning area**

#### **3.12.1.1 Computing K-fucntion estimation**

```{r}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

#### **3.12.1.2 Performing Complete Spatial Randomness Test**

Similar to before, a hypothesis test will be conducted to confirm the observed spatial patterns above. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### **3.12.2 Tampines planning area**

#### **3.12.2.1 Computing K-fucntion estimation**

```{r}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### **3.12.2.2 Performing Complete Spatial Randomness Test**

Similar to before, a hypothesis test will be conducted to confirm the observed spatial patterns above. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```

## **3.13 Analysing Spatial Point Process Using L-Function**

The L-function is a method used to analyze spatial point patterns by transforming the K-function to be more interpretable, particularly by normalizing the function against a theoretical CSR model. This section covers how to compute the L-function estimation and perform a Monte Carlo simulation test using the  [*Lest()*](https://rdrr.io/cran/spatstat/man/Lest.html) and *envelope()* of **spatstat** package.

### **3.13.1 Choa Chu Kang planning area**

#### **3.13.1.1 Computing L-fucntion estimation**

To compute the L-function estimation for Choa Chu Kang, use the `Lest()` function with the "Ripley" correction. Then, plot the results.

```{r}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

#### **3.13.1.2** Performing Complete Spatial Randomness Test

Similar to before, a hypothesis test will be conducted to confirm the observed spatial patterns above. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

### **3.13.2 Tampines planning area**

#### **3.13.2.1 Computing L-fucntion estimation**

```{r}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### **3.13.2.2** Performing Complete Spatial Randomness Test

Similar to before, a hypothesis test will be conducted to confirm the observed spatial patterns above. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_tm.csr, . - r ~ r, xlab="d", ylab="L(d)-r", xlim=c(0,500))
```
